package se.haleby.rps.port.http;

import io.javalin.Javalin;
import se.haleby.rps.application.GameApplicationService;
import se.haleby.rps.domain.model.Move;
import se.haleby.rps.projection.endedgames.EndedGamesProjection;
import se.haleby.rps.projection.ongoinggames.OngoingGamesProjection;

import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.Objects.requireNonNull;
import static se.haleby.rps.domain.model.State.ONGOING;

public class GameApi {

    private final Javalin app;
    private final int port;

    public GameApi(int port, GameApplicationService gameApplicationService, OngoingGamesProjection ongoingGamesProjection, EndedGamesProjection endedGamesProjection) {
        this.port = port;
        app = Javalin.create();
        app.contextPath("/api/games")
                .defaultContentType("text/plain")
                .enableAutogeneratedEtags()
                .disableStartupBanner()
                .enableCaseSensitiveUrls();

        // API
        app.put("/:gameId", ctx -> {
            String gameId = requireNonNull(ctx.pathParam("gameId"));
            String player = requireNonNull(ctx.header("player"));
            String move = ctx.formParam("move");

            final CompletableFuture<String> future;
            if (move == null) {
                future = gameApplicationService.startGame(gameId, player).thenApply(__ -> "Game started");
            } else {
                future = gameApplicationService.makeMove(gameId, player, Move.valueOf(move.toUpperCase())).thenApply(__ -> "Move made");
            }
            ctx.result(future);
        });

        app.get("", ctx -> {
            boolean ongoing = Boolean.valueOf(ctx.queryParam("joinable", "true"));
            boolean ended = Boolean.valueOf(ctx.queryParam("ended", "true"));
            Stream<GameDTO> ongoingGames = ongoing ? ongoingGamesProjection.findAll().stream().map(ongoingGame -> new GameDTO(ongoingGame.gameId(), ongoingGame.playerId1(), ongoingGame.playerId2(), null, ONGOING, ongoingGame.joinable())) : Stream.empty();
            Stream<GameDTO> endedGames = ended ? endedGamesProjection.findAll().stream().map(endedGame -> new GameDTO(endedGame.gameId(), endedGame.playerId1(), endedGame.playerId2(), endedGame.winnerId(), endedGame.state(), false)) : Stream.empty();
            ctx.json(Stream.concat(ongoingGames, endedGames).collect(Collectors.toList()));
        });
    }

    public void start() {
        app.start(port);
    }

    public void stop() {
        app.stop();
    }
}